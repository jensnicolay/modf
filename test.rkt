#lang racket

(require "ast.rkt")
(require "machine.rkt")

;(provide (all-defined-out))

(define (add-append e)
  `(letrec ((append (lambda (l1 l2)
                      (let ((_a_t1 (null? l1)))
                        (if _a_t1
                            l2
                            (let ((_a_t2 (car l1)))
                              (let ((_a_t3 (cdr l1)))
                                (let ((_a_t4 (append _a_t3 l2)))
                                  (cons _a_t2 _a_t4)))))))))
     ,e))

(define (add-equal? e)
  `(letrec ((equal? (lambda (x1 x2)
                      (let ((_b_t2 (pair? x1)))
                        (if _b_t2
                            (let ((_b_t3 (pair? x2)))
                              (if _b_t3
                                  (let ((_b_t4 (car x1)))
                                    (let ((_b_t5 (car x2)))
                                      (let ((_b_t6 (equal? _b_t4 _b_t5)))
                                        (if _b_t6
                                            (let ((_b_t7 (cdr x1)))
                                              (let ((_b_t8 (cdr x2)))
                                                (equal? _b_t7 _b_t8)))
                                            #f))))
                                  #f))
                            (eq? x1 x2))))))
     ,e))
;; Free variables: list set-car! set-cdr!
(define (add-cars e)
  `(let ((cadr (lambda (p) (let ((_p0 (cdr p))) (car _p0)))))
     (let ((caar (lambda (p) (let ((_p0 (car p))) (car _p0)))))
       (let ((cddr (lambda (p) (let ((_p0 (cdr p))) (cdr _p0)))))
         (let ((caadr (lambda (p) (let ((_p0 (cdr p))) (let ((_p1 (car _p0))) (car _p1))))))
           (let ((cdadr (lambda (p) (let ((_p0 (cdr p))) (let ((_p1 (car _p0))) (cdr _p1))))))
             (let ((caddr (lambda (p) (let ((_p0 (cdr p))) (let ((_p1 (cdr _p0))) (car _p1))))))
               (let ((cdddr (lambda (p) (let ((_p0 (cdr p))) (let ((_p1 (cdr _p0))) (cdr _p1))))))
                 (let ((cadddr (lambda (p) (let ((_p0 (cdr p))) (let ((_p1 (cdr _p0))) (let ((_p2 (cdr _p1))) (car _p2)))))))
                   ,e)))))))))

(define (add-map e)
  `(letrec ((map (lambda (f l)
                   (let ((_p0 (pair? l)))
                     (if _p0
                         (let ((_p1 (car l)))
                           (let ((_p2 (f _p1)))
                             (let ((_p3 (cdr l)))
                               (let ((_p4 (map f _p3)))
                                 (cons _p2 _p4)))))
                         '())))))
     ,e))

(define (add-length e)
  `(letrec ((length (lambda (l)
                      (let ((_p0 (null? l)))
                        (if _p0
                            0
                            (let ((_p1 (cdr l)))
                              (let ((_p2 (length _p1)))
                                (+ 1 _p2))))))))
     ,e))

(define (add-reverse e)
  `(let ((reverse (lambda (l)
                   (letrec ((reverse-acc (lambda (l acc)
                                           (let ((c (null? l)))
                                             (if c
                                                 acc
                                                 (let ((u (cdr l)))
                                                   (let ((v (car l)))
                                                     (let ((w (cons v acc)))
                                                       (reverse-acc u w)))))))))
                     (reverse-acc l '())))))
    ,e))

(define (add-list? e)
  `(letrec ((list? (lambda (l)
                     (let ((u (null? l)))
                       (if u
                           #t
                           (let ((v (pair? l)))
                             (if v
                                 (let ((w (cdr l)))
                                   (list? w))
                                 #f)))))))
     ,e))

(define (add-assoc e)
  `(letrec ((assoc (lambda (x l)
                     (let ((c (null? l)))
                       (if c
                           #f
                           (let ((binding (car l)))
                             (let ((key (car binding)))
                               (let ((m (equal? key x)))
                                 (if m
                                     binding
                                     (let ((rest (cdr l)))
                                       (assoc x rest)))))))))))
    ,e))

(define Tsq '((lambda (x) (* x x)) 8))
(define Tloopy1 '(letrec ((f (lambda () (f)))) (f)))
(define Tloopy2 '((lambda (x) (x x)) (lambda (y) (y y))))
(define Tsafeloopy1 '(letrec ((count (lambda (n) (let ((t (= n 0))) (if t 123 (let ((u (- n 1))) (let ((v (count u))) v))))))) (count 8)))
(define Thellomemo '(let ((f (lambda (x) x))) (let ((u (f 1))) (f 2))))
(define Thelloset! '(let ((x 1)) (let ((f (lambda (y) (let ((oldx x)) (let ((_ (set! x y))) oldx))))) (let ((_ (f 1))) (let ((__ (f "foo"))) (f 1))))))
(define Thellomemoset! '(let ((f (lambda (x) (let ((y (set! x "hehe"))) x)))) (let ((u (f 1))) (f 2))))
(define Tfac (file->value "test/fac.scm"))
(define Tfib (file->value "test/fib.scm"))
(define Tblur (file->value "test/blur.scm"))
(define Teta (file->value "test/eta.scm"))
(define Tgcipd (file->value "test/gcipd.scm"))
(define Tkcfa2 (file->value "test/kcfa2.scm"))
(define Tkcfa3 (file->value "test/kcfa3.scm"))
(define Tloop2 (file->value "test/loop2.scm"))
(define Tmj09 (file->value "test/mj09.scm"))
(define Trotate (file->value "test/rotate.scm"))
(define Tsat (file->value "test/sat.scm"))
(define Trsa (file->value "test/rsa.scm"))
(define Tfactor (add-reverse (file->value "test/factor.scm")))
(define Tprimtest (file->value "test/primtest.scm"))
(define Tregex (add-equal? (file->value "test/regex.scm")))
(define Tcpstak (file->value "test/cpstak.scm"))
(define Tchurchnums (file->value "test/churchnums.scm"))
(define Tnqueens (add-append (file->value "test/nqueens.scm")))
(define Tfib-mut (file->value "test/fib-mut.scm"))
(define Taccount (file->value "test/account.scm"))
(define Tcollatz (file->value "test/collatz.scm"))
(define Tscm2java (add-length (add-list? (file->value "test/scm2java.scm"))))
(define Tmceval (add-length (add-cars (add-map (file->value "test/mceval.scm")))))
(define Tmceval2 (add-equal? (add-cars (add-assoc (add-map (file->value "test/mceval2.scm"))))))
(define Tboyer (add-equal? (add-cars (file->value "test/boyer.scm"))))
(define Tack (add-equal? (file->value "test/ack.scm")))
(define Tdderiv (add-equal? (add-cars (add-map (file->value "test/dderiv.scm")))))
(define Ttakl (add-equal? (file->value "test/takl.scm")))
(define Tdivrec (add-cars (add-equal? (file->value "test/divrec.scm"))))
(define Ttreeadd1 (file->value "test/treeadd1.scm"))
(define Ttreeadd2 (file->value "test/treeadd2.scm"))
(define Ttreeadd3 (file->value "test/treeadd3.scm"))
(define Ttreeadd (file->value "test/treeadd.scm"))
(define Tsound1 (file->value "test/sound1.scm"))
(define Tsound2 (file->value "test/sound2.scm"))
(define Tsound3 (file->value "test/sound3.scm"))
(define Tsound4 (file->value "test/sound4.scm"))
(define Tsound5 (file->value "test/sound5.scm"))
(define Tsound6 (file->value "test/sound6.scm"))
(define Tsound7 (file->value "test/sound7.scm"))
(define Tsound8 (file->value "test/sound8.scm"))
(define Ttreenode1 '(let ((tree-node (lambda (l) (let ((this (cons 1 2))) (let ((a this)) (let ((uu (set-car! a l))) a))))))
           (letrec ((f (lambda (levels) (let ((left #f)) (let ((c (<= levels 1))) (let ((u (if c (set! left 'null) (let ((n (- levels 1))) (let ((ll (f n))) (set! left ll)))))) (tree-node left)))))))
             (f 3))))
(define Tdestruc (add-length (file->value "test/destruct.scm")))
(define Tgrid (add-equal? (file->value "test/grid.scm")))
(define Tgrid1 (add-equal? (file->value "test/grid1.scm")))
(define Tfannkuch (file->value "test/fannkuch.scm"))
(define Tmatrix (file->value "test/matrix.scm"))
(define Tspectralnorm (file->value "test/spectralnorm.scm"))
(define Tsieve (file->value "test/sieve.scm"))
(define Tmandelbrot (file->value "test/mandelbrot.scm"))
(define Tpartialsums (file->value "test/partialsums.scm"))

(define (test-machine e expected)
  (let ((result
            (with-handlers ((exn:fail?
                             (lambda (exc) (if (eq? expected 'FAIL)
                                             'FAIL
                                             (begin
                                               (printf "unexpected failure for ~a:\n" e)
                                               (raise exc))))))
              (conc-eval (compile e)))))
         (unless (equal? result expected)
           (error (format "wrong result for ~a:\n\texpected ~a\n\tgot      ~a" e expected result)))))

(test-machine '123 123)
(test-machine '(let ((x 10)) x) 10)
(test-machine '(let ((x 10)) (let ((y 20)) y)) 20)
(test-machine '(let ((x 10)) (let ((y 20)) x)) 10)
(test-machine '(let ((x 10)) (let ((x 20)) x)) 20)
(test-machine '(let ((x 123)) (let ((u (let ((x #f)) "dummy"))) x)) 123)

(test-machine '(+ 1 1) 2)
(test-machine '(let ((x (+ 1 1))) x) 2)
(test-machine '(let ((x (let ((z 3)) z))) x) 3)
(test-machine '(let ((f (lambda () (- 5 3)))) (f)) 2)
(test-machine '(let ((f (lambda (x) (* x x)))) (f 4)) 16)
(test-machine '(let ((f (lambda (x) x))) (let ((v (+ 3 9))) v)) 12)
(test-machine '(let ((x 123)) (let ((f (lambda () x))) (f))) 123)
(test-machine '(let ((f (lambda (x) x))) (let ((v (f 999))) v)) 999)
(test-machine '(let ((g (lambda (v) v))) (let ((f (lambda (n) (let ((m (g 123))) (* m n))))) (f 2))) 246)
(test-machine '(let ((f (lambda (x) x))) (let ((u (f 1))) (f 2))) 2)
(test-machine '(let ((f (lambda (y) (let ((x y)) x)))) (let ((z (f "foo"))) (f 1))) 1)
(test-machine '(let ((f (lambda (x) (let ((v x)) v)))) (f 123)) 123)
(test-machine '(let ((f (lambda (x) (let ((i (lambda (a) a))) (i x))))) (let ((z1 (f 123))) (let ((z2 (f #t))) z2))) #t)

(test-machine '(if #t 1 2) 1)
(test-machine '(if #f 1 2) 2)
(test-machine '(if #t (+ 3 5) (- 4 6)) 8)
(test-machine '(if #f (+ 3 5) (- 4 6)) -2)
(test-machine '(let ((f (lambda (x) (* x x)))) (let ((v (f 4))) (if v (f 5) (f 6)))) 25)
(test-machine '(if #t (let ((x 1)) x) (let ((x 2)) x)) 1)
(test-machine '(if #f (let ((x 1)) x) (let ((x 2)) x)) 2)
(test-machine '(let ((x (if #t 1 2))) x) 1)
(test-machine '(let ((x (if #f 1 2))) x) 2)

(test-machine '(let ((f (lambda (x) (lambda (y) x)))) (let ((v (f 123))) (v 999))) 123)
(test-machine '(let ((f (lambda (x) (lambda (x) x)))) (let ((v (f 123))) (v 999))) 999)
(test-machine '(let ((f (lambda (g) (g 678)))) (let ((id (lambda (x) x))) (f id))) 678)
(test-machine '(let ((f (lambda (g x) (g x)))) (let ((id (lambda (x) x))) (f id 789))) 789)
(test-machine '(let ((f (lambda (g) (lambda (x) (g x))))) (let ((sq (lambda (x) (* x x)))) (let ((ff (f sq))) (ff 11)))) 121)


(test-machine '(letrec ((f (lambda (x) (if x "done" (f #t))))) (f #f)) "done")
(test-machine '(letrec ((f (lambda (x) (let ((v (= x 2))) (if v x (f (+ x 1))))))) (f 0)) 2)
(test-machine '(letrec ((fac (lambda (n) (let ((v (= n 0))) (if v 1 (let ((m (- n 1))) (let ((w (fac m))) (* n w)))))))) (fac 1)) 1)
(test-machine '(letrec ((fac (lambda (n) (let ((v (= n 0))) (if v 1 (let ((m (- n 1))) (let ((w (fac m))) (* n w)))))))) (fac 3)) 6)
(test-machine '(letrec ((fib (lambda (n) (let ((c (< n 2))) (if c n (let ((n1 (- n 1))) (let ((n2 (- n 2))) (let ((f1 (fib n1))) (let ((f2 (fib n2))) (+ f1 f2)))))))))) (fib 1)) 1)
(test-machine '(letrec ((fib (lambda (n) (let ((c (< n 2))) (if c n (let ((n1 (- n 1))) (let ((f1 (fib n1))) (let ((n2 (- n 2))) (let ((f2 (fib n2))) (+ f1 f2)))))))))) (fib 1)) 1)
(test-machine '(letrec ((fib (lambda (n) (let ((c (< n 2))) (if c n (let ((n1 (- n 1))) (let ((n2 (- n 2))) (let ((f1 (fib n1))) (let ((f2 (fib n2))) (+ f1 f2)))))))))) (fib 3)) 2)
(test-machine '(letrec ((fib (lambda (n) (let ((c (< n 2))) (if c n (let ((n1 (- n 1))) (let ((f1 (fib n1))) (let ((n2 (- n 2))) (let ((f2 (fib n2))) (+ f1 f2)))))))))) (fib 3)) 2)
(test-machine '(letrec ((count (lambda (n) (let ((t (= n 0))) (if t 123 (let ((u (- n 1))) (let ((v (count u))) v))))))) (count 8)) 123)

(test-machine 'x 'FAIL)
(test-machine '(let ((f (lambda () f))) (f)) 'FAIL)

; set!
(test-machine '(let ((x 123)) (let ((u (if #t (set! x 456) (set! x 789)))) x)) 456)
(test-machine '(let ((x 123)) (let ((u (if #f (set! x 456) (set! x 789)))) x)) 789)
(test-machine '(let ((y 999)) (let ((x 123)) (let ((u (if x (set! y 456) (set! y 789)))) y))) 456)
(test-machine '(let ((x 123)) (let ((u (set! x 456))) x)) 456)
(test-machine '(let ((x 123)) (let ((u (set! x 456))) (let ((uu (set! x 789))) x))) 789)
(test-machine '(let ((x 123)) (let ((u (if x (set! x 456) (set! x 789)))) x)) 456)
(test-machine '(let ((x 123)) (let ((u (set! x #f))) (let ((uu (if x (set! x 456) (set! x 789)))) x))) 789)
(test-machine '(let ((x #t)) (let ((f (lambda () (set! x #f)))) (let ((u (f))) x))) #f)
(test-machine '(let ((x #t)) (let ((g (lambda () (set! x #f)))) (let ((f (lambda (h) (h)))) (let ((u (f g))) x)))) #f)
(test-machine '(let ((x 2)) (let ((f (lambda (y) (let ((oldx x)) (let ((_ (set! x y))) oldx))))) (f 1))) 2)
(test-machine '(let ((x 1)) (let ((f (lambda (y) (let ((oldx x)) (let ((_ (set! x y))) oldx))))) (let ((__ (f "foo"))) (f 1)))) "foo")
(test-machine '(let ((x 1)) (let ((f (lambda (y) (let ((oldx x)) (let ((_ (set! x y))) oldx))))) (let ((_ (f 1))) (let ((__ (f "foo"))) (f 1))))) "foo")
(test-machine '(let ((f (lambda (x) (let ((y (set! x "hoho"))) x)))) (f 1)) "hoho")
(test-machine '(let ((f (lambda (x) (let ((y (set! x "hehe"))) x)))) (let ((u (f 1))) (f 2))) "hehe")
(test-machine '(let ((x 123)) (let ((f (lambda (y) y))) (let ((v (set! x 456))) (let ((u (f v))) x)))) 456)
(test-machine '(let ((x 123)) (let ((f (lambda (x) x))) (let ((v (set! x 456))) (let ((u (f v))) x)))) 456)
(test-machine '(let ((x 123)) (let ((f (lambda (x y) x))) (let ((v (set! x 456))) (let ((u (f v 789))) x)))) 456)
(test-machine '(let ((x 123)) (let ((c (set! x 456))) (let ((u (if c 789 0))) x))) 456)
(test-machine '(let ((x 123)) (let ((c (set! x 456))) (let ((u (if c (set! x 789) (set! x 0)))) x))) 789)
(test-machine '(let ((x 123)) (let ((y (set! x 456))) x)) 456)
(test-machine '(let ((x 123)) (let ((y (set! x 456))) (let ((u (set! x 789))) x))) 789)
(test-machine '(let ((x 123)) (let ((y (set! x 456))) (let ((u (let ((z (set! x 789))) 0))) x))) 789)
(test-machine '(let ((x 123)) (let ((y (set! x 456))) (let ((u (set! x 0))) (let ((uu (let ((z (set! x 789))) 0))) x)))) 789)


(struct substitute node with)

(test-incremental '(let ((x 1))
                     (let ((y (+ x 1)))
                       (let ((c (= y 2)))
                         (let ((z (if c (set! x 2) (set! x 3))))
                           (+ x y)))))
                  (lambda (ast)
                    (match-let ((«let» _ _ lit _) ast)
                      (← lit (compile '2))
                    (let ((e-let ))
                                       (e-new (compile `(let ((y 5)) ,e-app))))
                                  (cons e-app e-new))))

                  
                  
                  
                                                        