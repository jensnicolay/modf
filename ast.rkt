#lang racket
(provide (all-defined-out))

(struct «lit» (l v) #:transparent #:methods gen:equal+hash ((define equal-proc (lambda (s1 s2 requal?)
                                                                   (= («lit»-l s1) («lit»-l s2))))
                                              (define hash-proc (lambda (s rhash) («lit»-l s)))
                                              (define hash2-proc (lambda (s rhash) (equal-secondary-hash-code («lit»-l s)))))
  #:property prop:custom-write (lambda (v p w?)
                                 (fprintf p "~a" («lit»-v v))))
(struct «id» (l x) #:transparent #:methods gen:equal+hash ((define equal-proc (lambda (s1 s2 requal?)
                                                                                (= («id»-l s1) («id»-l s2))))
                                                           (define hash-proc (lambda (s rhash) («id»-l s)))
                                                           (define hash2-proc (lambda (s rhash) (equal-secondary-hash-code («id»-l s)))))
  #:property prop:custom-write (lambda (v p w?)
                                 (fprintf p "~a" («id»-x v))))
(struct «quo» (l e) #:transparent #:methods gen:equal+hash ((define equal-proc (lambda (s1 s2 requal?)
                                                                   (= («quo»-l s1) («quo»-l s2))))
                                              (define hash-proc (lambda (s rhash) («quo»-l s)))
                                              (define hash2-proc (lambda (s rhash) (equal-secondary-hash-code («quo»-l s))))))
(struct «lam» (l x e0) #:transparent #:methods gen:equal+hash ((define equal-proc (lambda (s1 s2 requal?)
                                                                   (= («lam»-l s1) («lam»-l s2))))
                                              (define hash-proc (lambda (s rhash) («lam»-l s)))
                                              (define hash2-proc (lambda (s rhash) (equal-secondary-hash-code («lam»-l s)))))
  #:property prop:custom-write (lambda (v p w?)
                                 (fprintf p "(lambda ~a ~a)" («lam»-x v) («lam»-e0 v))))  
(struct «app» (l e0 es) #:transparent #:methods gen:equal+hash ((define equal-proc (lambda (s1 s2 requal?)
                                                                   (= («app»-l s1) («app»-l s2))))
                                              (define hash-proc (lambda (s rhash) («app»-l s)))
                                              (define hash2-proc (lambda (s rhash) (equal-secondary-hash-code («app»-l s)))))
  #:property prop:custom-write (lambda (v p w?)
                                 (fprintf p "~a" (cons («app»-e0 v) («app»-es v)))))
(struct «let» (l x e0 e1) #:transparent #:methods gen:equal+hash ((define equal-proc (lambda (s1 s2 requal?)
                                                                   (= («let»-l s1) («let»-l s2))))
                                              (define hash-proc (lambda (s rhash) («let»-l s)))
                                              (define hash2-proc (lambda (s rhash) (equal-secondary-hash-code («let»-l s)))))
    #:property prop:custom-write (lambda (v p w?)
                                 (fprintf p "(let ((~a ~a)) ~a)" («let»-x v) («let»-e0 v) («let»-e1 v))))

(struct «letrec» (l x e0 e1) #:transparent #:methods gen:equal+hash ((define equal-proc (lambda (s1 s2 requal?)
                                                                   (= («letrec»-l s1) («letrec»-l s2))))
                                              (define hash-proc (lambda (s rhash) («letrec»-l s)))
                                              (define hash2-proc (lambda (s rhash) (equal-secondary-hash-code («letrec»-l s)))))
      #:property prop:custom-write (lambda (v p w?)
                                 (fprintf p "(letrec ((~a ~a)) ~a)" («letrec»-x v) («letrec»-e0 v) («letrec»-e1 v))))

(struct «if» (l e0 e1 e2) #:transparent #:methods gen:equal+hash ((define equal-proc (lambda (s1 s2 requal?)
                                                                   (= («if»-l s1) («if»-l s2))))
                                              (define hash-proc (lambda (s rhash) («if»-l s)))
                                              (define hash2-proc (lambda (s rhash) (equal-secondary-hash-code («if»-l s)))))
    #:property prop:custom-write (lambda (v p w?)
                                 (fprintf p "(if ~a ~a ~a)" («if»-e0 v) («if»-e1 v) («if»-e2 v))))
(struct «set!» (l x e0) #:transparent #:methods gen:equal+hash ((define equal-proc (lambda (s1 s2 requal?)
                                                                   (= («set!»-l s1) («set!»-l s2))))
                                              (define hash-proc (lambda (s rhash) («set!»-l s)))
                                              (define hash2-proc (lambda (s rhash) (equal-secondary-hash-code («set!»-l s)))))
        #:property prop:custom-write (lambda (v p w?)
                                 (fprintf p "(set! ~a ~a)" («set!»-x v) («set!»-e0 v))))




(define (compile e)
    (define tag!
    (let ((l -1))
      (lambda ()
        (set! l (add1 l))
        l)))
  (define (compile2 e)
    (match e
      ((? symbol? v) («id» (tag!) (symbol->string v)))
      ((? boolean? v) («lit» (tag!) v))
      ((? number? v) («lit» (tag!) v))
      ((? string? v)(«lit» (tag!) v))
      ((? char? v) («lit» (tag!) v))
      (`(quote ,e) («quo» (tag!) e))
      (`(lambda ,x ,e) («lam» (tag!) (map compile2 x) (compile2 e)))
      (`(if ,ae ,e1 ,e2) («if» (tag!) (compile2 ae) (compile2 e1) (compile2 e2)))
      (`(let ((,x ,e0)) ,e1) («let» (tag!) (compile2 x) (compile2 e0) (compile2 e1)))
      (`(letrec ((,x ,e0)) ,e1) («letrec» (tag!) (compile2 x) (compile2 e0) (compile2 e1)))
      (`(set! ,x ,ae) («set!» (tag!) (compile2 x) (compile2 ae)))
      (`(,rator . ,rands) («app» (tag!) (compile2 rator) (map compile2 rands)))
      ((? «id»?) e)
      ((? «lam»?) e)
      ((? «let»?) e)
      ((? «letrec»?) e)
      ((? «if»?) e)
      ((? «set!»?) e)
      ((? «quo»?) e)
      ((? «app»?) e)
      ((? «lit»?) e)
      (_ (error "cannot handle expression" e))))
  (compile2 e))
         
(define (ae? e)
  (match e
    ((«lit» _ _) #t)
    ((«id» _ _) #t)
    ((«lam» _ _ _) #t)
    ((«quo» _ e) (not (pair? e))) 
    (_ #f)))

(define (children e)
  (match e
    ((«id» _ _) (set))
    ((«lit» _ _) (set))
    ((«lam» _ x e) (set-add (list->set x) e))
    ((«let» _ x e0 e1) (set x e0 e1))
    ((«letrec» _ x e0 e1) (set x e0 e1))
    ((«if» _ ae e1 e2) (set ae e1 e2))
    ((«set!» _ x ae) (set x ae))
    ((«quo» _ _) (set))
    ((«app» _ rator rands) (set-add (list->set rands) rator))
    (_ (error "cannot handle expression" e))))

;(define (parent e ast)
;  (let ((cs (children ast)))
;    (if (set-member? cs e)
;        ast
;        (let loop ((cs cs))
;          (if (set-empty? cs)
;              #f
;              (let ((p (parent e (set-first cs))))
;                (or p (loop (set-rest cs)))))))))


(define (parent-map ast)
  (define (traverse-ast S W)
    (if (set-empty? W)
        S
        (let* ((e (set-first W))
               (E* (children e))
               (S* (for/fold ((S S)) ((e* E*))
                     (hash-set S e* e)))
               (W* (set-union (set-rest W) E*)))
          (traverse-ast S* W*))))
  (traverse-ast (hash) (set ast)))

(define (make-parent ast)
  (let ((P (parent-map ast)))
    (lambda (e)
      (hash-ref P e #f))))

(define (nodes ast) (for/fold ((cs (list ast))) ((c (children ast))) (append cs (nodes c))))

(define (free e)
  (define (f e env)
    (match e
      ((«id» _ x) (if (set-member? env x)
                      (set)
                      (set x)))
      ((«lam» _ x e) (f e (set-union env (list->set (map «id»-x x)))))
      ((«let» _ x e0 e1) (set-union (f e0 env) (f e1 (set-add env («id»-x x)))))
      ((«letrec» _ x e0 e1) (set-union (f e0 (set-add env («id»-x x))) (f e1 (set-add env («id»-x x)))))
      ((«if» _ ae e1 e2) (set-union (f ae env) (f e1 env) (f e2 env)))
      ((«set!» _ x ae) (set-union (f x env) (f ae env)))
      ((«quo» _ _) (set))
      ((«app» _ rator rands) (set-union (f rator env) (for/fold ((xs (set))) ((rand rands)) (set-union xs (f rand env)))))
      ((«id» _ _) (set))
      ((«lit» _ _) (set))
      (_ (error "cannot handle expression" e))))
  (f e (set)))


;(define generate-name!
;  (let ((c -1))
;    (lambda ()
;      (set! c (add1 c))
;      (string-append "æ" (number->string c)))))
;
;(define (to-anf e)
;  (to-anf-k e (lambda (a) a)))
;                                          
;(define (to-anf-k e k)
;  (match e
;    ((«lit» _ _) (k e))
;    ((«id» _ _)  (k e))
;    ((«quo» _ e) (if (not (pair? e))
;                     (k e)
;                     'TODO))
;    ((«lam» l x e) (k («lam» l x (to-anf e))))
;    ((«let» l x e0 e1) (to-anf-k e0 (lambda (a0) («let» l x a0 (to-anf e1)))))
;    ((«letrec» l x e0 e1) (to-anf-k e0 (lambda (a0) («letrec» l x a0 (to-anf e1)))))
;    ((«if» l e0 e1 e2) (to-anf-k e0 (lambda (a0) («if» l e0 (to-anf e1) (to-anf e2)))))
;    ((«set!» l x e0) (to-anf-k e0 (lambda (a0) (k («set!» l x a0)))))
;    ((«app» l rator rands) (to-anf-k rator (lambda (a-rator)
;                                             (let loop ((rands rands) (a-rands '()))
;                                               (if (null? rands)
;                                                   («app» l a-rator (reverse a-rands))
;                                                   (to-anf-k (car rands) (lambda (a-rand)
;                                                                           (loop (cdr rands) (cons a-rand a-rands)))))))))
;    (_ (error "cannot handle expression" e))))
;
;(define (to-anf-bind e k)
;  (to-anf-k e (lambda (a)
;                (if (ae? a)
;                    (k a)
;                    (let ((name (generate-name!)))
;                      («let» (tag!)
;                             («id» (tag!) name)
;                             (k («id» (tag!) name))))))))

  
      
